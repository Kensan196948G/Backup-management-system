# パフォーマンス要件書

**プロジェクト名:** バックアップ管理システム WebUI
**バージョン:** 1.0.0
**作成日:** 2026-02-25

---

## 1. パフォーマンス目標

### 1.1 フロントエンド Web Vitals

| 指標 | 目標値 | 説明 |
|------|--------|------|
| LCP（Largest Contentful Paint） | < 2.5 秒 | 最大コンテンツ描画時間 |
| FID（First Input Delay） | < 100ms | 初回入力遅延 |
| CLS（Cumulative Layout Shift） | < 0.1 | 累積レイアウトシフト |
| FCP（First Contentful Paint） | < 2.0 秒 | 初回コンテンツ描画 |
| TTI（Time to Interactive） | < 3.5 秒 | インタラクティブ開始時間 |

### 1.2 API レスポンスタイム

| API 種別 | p50 目標 | p95 目標 | p99 目標 |
|---------|---------|---------|---------|
| 認証 API | < 100ms | < 300ms | < 500ms |
| ダッシュボードサマリー | < 200ms | < 500ms | < 1000ms |
| ジョブ一覧（25件） | < 100ms | < 300ms | < 500ms |
| レポート生成（PDF） | < 3000ms | < 8000ms | < 15000ms |
| ファイルエクスポート（CSV） | < 500ms | < 2000ms | < 5000ms |

### 1.3 同時接続

| 指標 | 要件 |
|------|------|
| 同時接続ユーザー数（通常） | 100 ユーザー |
| 同時接続ユーザー数（ピーク） | 300 ユーザー |
| WebSocket 同時接続数 | 50 接続 |
| API スループット | 500 req/sec |

---

## 2. フロントエンド最適化

### 2.1 バンドル最適化

| 手法 | 実装方法 |
|------|---------|
| コード分割 | React.lazy + Suspense（ルートレベル） |
| Tree Shaking | Vite デフォルト（ES modules） |
| バンドルサイズ目標 | 初期ロード < 200KB（gzip） |
| アセット圧縮 | Gzip / Brotli（Nginx 設定） |

**バンドル分割戦略:**
```
main.js          - コアフレームワーク（React / Router）
dashboard.js     - ダッシュボードチャンク
jobs.js          - ジョブ管理チャンク
reports.js       - レポートチャンク（PDF生成含む）
settings.js      - 設定チャンク
vendor.js        - 安定した依存関係（長期キャッシュ）
```

### 2.2 キャッシュ戦略

| リソース種別 | キャッシュ戦略 | TTL |
|-----------|-------------|-----|
| 静的ファイル（JS/CSS） | content-hash + 長期キャッシュ | 1 年 |
| フォント | 長期キャッシュ | 1 年 |
| API レスポンス（変更頻度低） | TanStack Query キャッシュ | 5 分 |
| ダッシュボードデータ | TanStack Query キャッシュ | 30 秒 |
| ジョブ一覧 | TanStack Query キャッシュ | 60 秒 |

### 2.3 画像最適化

- WebP / AVIF フォーマットの優先使用
- 遅延読み込み（`loading="lazy"`）
- 適切なサイズでの提供（`srcset`）
- SVG アイコンのインライン化

### 2.4 レンダリング最適化

| 手法 | 適用箇所 |
|------|---------|
| React.memo | 再レンダリングが頻繁なリストアイテム |
| useMemo / useCallback | 高コストな計算・コールバック |
| 仮想スクロール | 1000件以上のリスト表示 |
| デバウンス | 検索入力（300ms） |
| スロットリング | スクロールイベント（100ms） |

---

## 3. バックエンド最適化

### 3.1 データベースクエリ最適化

- N+1 クエリの防止（SQLAlchemy の `selectinload` / `joinedload`）
- 重要クエリの実行計画（EXPLAIN ANALYZE）による定期確認
- スロークエリログの有効化（> 100ms）
- コネクションプールの設定

**コネクションプール設定:**
```python
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,        # 通常接続数
    max_overflow=10,     # 最大追加接続数
    pool_timeout=30,     # 接続待機タイムアウト
    pool_recycle=3600,   # 接続リサイクル（1時間）
)
```

### 3.2 キャッシュ（Redis）

| キャッシュ対象 | TTL | 無効化タイミング |
|------------|-----|--------------|
| ダッシュボードサマリー | 30 秒 | ジョブ実行完了時 |
| ストレージ使用量 | 5 分 | 手動更新時 |
| ユーザー権限情報 | 15 分 | ユーザー更新時 |

### 3.3 非同期処理

- レポート生成 / PDF 出力: Celery タスクキューで非同期実行
- バックアップジョブ実行: Celery Beat でスケジュール管理
- 大量データエクスポート: ストリーミングレスポンス

---

## 4. インフラパフォーマンス

### 4.1 Nginx 設定

```nginx
# Gzip 圧縮
gzip on;
gzip_types text/plain text/css application/json application/javascript;
gzip_min_length 1000;

# Keepalive
keepalive_timeout 65;
keepalive_requests 100;

# バッファリング
proxy_buffering on;
proxy_buffer_size 128k;
proxy_buffers 4 256k;
```

### 4.2 PostgreSQL チューニング

| パラメータ | 設定値 | 説明 |
|-----------|--------|------|
| `shared_buffers` | RAM の 25% | 共有バッファ |
| `effective_cache_size` | RAM の 75% | OS キャッシュ見積もり |
| `work_mem` | 256MB | ソート・ハッシュ操作 |
| `maintenance_work_mem` | 1GB | VACUUM・インデックス構築 |
| `max_connections` | 200 | 最大接続数 |

---

## 5. パフォーマンス計測・監視

### 5.1 フロントエンド計測

- **ツール:** Lighthouse / Web Vitals ライブラリ
- **頻度:** CI/CD パイプラインで PR ごとに計測
- **閾値:** 目標値を下回った場合はビルド警告

### 5.2 バックエンド計測

- **APM:** OpenTelemetry + Jaeger（トレース）
- **メトリクス:** Prometheus + Grafana
- **アラート:** API p95 > 1000ms で通知

---

## 更新履歴

| 日付 | バージョン | 更新者 | 内容 |
|------|-----------|--------|------|
| 2026-02-25 | 1.0.0 | システム管理者 | 初版作成 |
